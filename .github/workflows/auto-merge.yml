name: Auto-Merge Owner's PRs
on:
  pull_request:
    types: [opened, reopened, synchronize]
permissions:
  contents: write
  pull-requests: write
jobs:
  auto-merge:
    runs-on: ubuntu-latest
    if: github.actor == 'dallae'
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        
      - name: Get Pull Request Details
        id: pr_details
        run: |
          echo "Pull Request Number: ${{ github.event.pull_request.number }}"
          echo "Pull Request Title: ${{ github.event.pull_request.title }}"
          echo "Pull Request URL: ${{ github.event.pull_request.html_url }}"
      
      - name: Diagnose Status Checks
        id: diagnostics
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT }}
          script: |
            // Get the combined status
            const { data: combinedStatus } = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.payload.pull_request.head.sha
            });
            
            console.log(`Combined status: ${combinedStatus.state}`);
            console.log(`Total status checks: ${combinedStatus.statuses.length}`);
            
            // Log detailed information about each status
            if (combinedStatus.statuses.length > 0) {
              console.log("\nDetailed Status Checks:");
              for (const status of combinedStatus.statuses) {
                console.log(`- ${status.context}: ${status.state} (${status.description})`);
                console.log(`  Target URL: ${status.target_url || 'N/A'}`);
              }
            }
            
            // Get check runs (GitHub Actions and other integrations)
            const { data: checks } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.payload.pull_request.head.sha
            });
            
            console.log(`\nTotal check runs: ${checks.total_count}`);
            
            // Count checks by status and conclusion
            const statusCounts = {};
            const conclusionCounts = {};
            const pendingChecks = [];
            const failingChecks = [];
            
            for (const check of checks.check_runs) {
              // Track status counts
              statusCounts[check.status] = (statusCounts[check.status] || 0) + 1;
              
              // Track conclusion counts (if completed)
              if (check.status === 'completed') {
                conclusionCounts[check.conclusion] = (conclusionCounts[check.conclusion] || 0) + 1;
              }
              
              // Track pending checks
              if (check.status !== 'completed') {
                pendingChecks.push({
                  name: check.name,
                  status: check.status,
                  startedAt: check.started_at
                });
              }
              
              // Track failing checks
              if (check.status === 'completed' && check.conclusion !== 'success') {
                failingChecks.push({
                  name: check.name,
                  conclusion: check.conclusion,
                  detailsUrl: check.details_url
                });
              }
            }
            
            console.log("\nCheck Run Status Summary:");
            for (const [status, count] of Object.entries(statusCounts)) {
              console.log(`- ${status}: ${count}`);
            }
            
            console.log("\nCheck Run Conclusion Summary:");
            for (const [conclusion, count] of Object.entries(conclusionCounts)) {
              console.log(`- ${conclusion}: ${count}`);
            }
            
            if (pendingChecks.length > 0) {
              console.log("\nPending Checks:");
              for (const check of pendingChecks) {
                console.log(`- ${check.name} (${check.status}, started: ${check.startedAt || 'N/A'})`);
              }
            }
            
            if (failingChecks.length > 0) {
              console.log("\nFailing Checks:");
              for (const check of failingChecks) {
                console.log(`- ${check.name} (${check.conclusion})`);
                console.log(`  Details: ${check.detailsUrl}`);
              }
            }
            
            // Check Required Status Checks
            let requiredChecksStatus = true;
            try {
              const { data: branch } = await github.rest.repos.getBranch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                branch: context.payload.pull_request.base.ref
              });
              
              if (branch.protection && branch.protection.required_status_checks) {
                console.log("\nRequired Status Checks:");
                console.log(`- Strict: ${branch.protection.required_status_checks.strict}`);
                console.log(`- Required Contexts: ${JSON.stringify(branch.protection.required_status_checks.contexts)}`);
                
                // Check which required checks are still pending or failing
                if (branch.protection.required_status_checks.contexts.length > 0) {
                  console.log("\nStatus of Required Checks:");
                  
                  for (const requiredContext of branch.protection.required_status_checks.contexts) {
                    // Check in statuses
                    const matchingStatus = combinedStatus.statuses.find(s => s.context === requiredContext);
                    
                    // Check in check runs
                    const matchingCheck = checks.check_runs.find(c => c.name === requiredContext);
                    
                    if (matchingStatus) {
                      console.log(`- ${requiredContext}: ${matchingStatus.state} (${matchingStatus.description || 'No description'})`);
                      if (matchingStatus.state !== 'success') {
                        requiredChecksStatus = false;
                      }
                    } else if (matchingCheck) {
                      console.log(`- ${requiredContext}: ${matchingCheck.status} / ${matchingCheck.conclusion || 'pending'}`);
                      if (matchingCheck.status !== 'completed' || matchingCheck.conclusion !== 'success') {
                        requiredChecksStatus = false;
                      }
                    } else {
                      console.log(`- ${requiredContext}: Not found (may be pending or not started)`);
                      requiredChecksStatus = false;
                    }
                  }
                }
              } else {
                console.log("\nNo branch protection rules with required status checks found.");
              }
            } catch (error) {
              console.log("\nError fetching branch protection rules:", error.message);
            }
            
            // Check PR mergeable status
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            console.log("\nPR Mergeable Status:");
            console.log(`- Mergeable: ${pr.mergeable}`);
            console.log(`- Mergeable State: ${pr.mergeable_state}`);
            
            // Check if PR has approved reviews
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            const approvals = reviews.filter(review => review.state === 'APPROVED');
            console.log(`\nApproved Reviews: ${approvals.length}`);
            
            // Set outputs for use in next steps
            const canMerge = 
              pr.mergeable === true && 
              pr.mergeable_state !== 'blocked' && 
              failingChecks.length === 0 &&
              pendingChecks.length === 0 &&
              requiredChecksStatus === true;
            
            core.setOutput('can_merge', canMerge);
            core.setOutput('mergeable', pr.mergeable);
            core.setOutput('mergeable_state', pr.mergeable_state);
            
            return {
              combinedState: combinedStatus.state,
              pendingChecksCount: pendingChecks.length,
              failingChecksCount: failingChecks.length,
              mergeable: pr.mergeable,
              mergeableState: pr.mergeable_state,
              canMerge: canMerge
            };

      # Wait for checks to complete if they're still running
      - name: Wait for Required Checks
        id: wait_for_checks
        if: steps.diagnostics.outputs.can_merge != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT }}
          script: |
            // Define maximum wait time (in minutes)
            const MAX_WAIT_MINUTES = 5;
            const POLL_INTERVAL_SECONDS = 10;
            const MAX_ATTEMPTS = (MAX_WAIT_MINUTES * 60) / POLL_INTERVAL_SECONDS;
            
            console.log(`Waiting for checks to complete (max ${MAX_WAIT_MINUTES} minutes)...`);
            
            for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
              console.log(`\nCheck attempt ${attempt + 1} of ${MAX_ATTEMPTS}`);
              
              // Get the latest PR status
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number
              });
              
              // Get check runs
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.payload.pull_request.head.sha
              });
              
              // Count pending checks
              const pendingChecks = checks.check_runs.filter(check => 
                check.status !== 'completed'
              );
              
              // Count failing checks
              const failingChecks = checks.check_runs.filter(check => 
                check.status === 'completed' && check.conclusion !== 'success'
              );
              
              console.log(`PR Mergeable: ${pr.mergeable}`);
              console.log(`Mergeable State: ${pr.mergeable_state}`);
              console.log(`Pending Checks: ${pendingChecks.length}`);
              console.log(`Failing Checks: ${failingChecks.length}`);
              
              // Check if everything is ready
              if (pr.mergeable === true && 
                  pr.mergeable_state !== 'blocked' && 
                  pendingChecks.length === 0 && 
                  failingChecks.length === 0) {
                console.log('\nAll checks passed! Ready to merge.');
                core.setOutput('can_merge', true);
                return { canMerge: true };
              }
              
              // If we have failing checks, no need to wait further
              if (failingChecks.length > 0) {
                console.log('\nSome checks failed. Cannot proceed with merge.');
                core.setOutput('can_merge', false);
                return { canMerge: false };
              }
              
              // Wait before next poll
              console.log(`\nWaiting ${POLL_INTERVAL_SECONDS} seconds before next check...`);
              await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL_SECONDS * 1000));
            }
            
            console.log(`\nReached maximum wait time of ${MAX_WAIT_MINUTES} minutes. Checks still not complete.`);
            core.setOutput('can_merge', false);
            return { canMerge: false };

      # Perform the merge if all checks pass
      - name: Auto-Merge PR
        if: steps.diagnostics.outputs.can_merge == 'true' || steps.wait_for_checks.outputs.can_merge == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT }}
          script: |
            console.log('Attempting to merge PR...');
            
            try {
              const { data: mergeResult } = await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
                merge_method: 'rebase'  // Using rebase method as specified
              });
              
              console.log('PR merged successfully!');
              console.log(`Message: ${mergeResult.message}`);
              console.log(`SHA: ${mergeResult.sha}`);
              
              // Add a comment to the PR
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: '✅ This PR was automatically merged by the Auto-Merge workflow because it was created by the repository owner.'
              });
              
            } catch (error) {
              console.log('Failed to merge PR:', error.message);
              
              // Add a comment about the failure
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: `❌ Auto-merge failed: ${error.message}`
              });
            }
