name: Auto-Merge Owner's PRs
on:
  pull_request:
    types: [opened, reopened, synchronize]
permissions:
  contents: write
  pull-requests: write
jobs:
  auto-merge:
    runs-on: ubuntu-latest
    if: github.actor == 'dallae'
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        
      - name: Get Pull Request Details
        id: pr_details
        run: |
          echo "Pull Request Number: ${{ github.event.pull_request.number }}"
          echo "Pull Request Title: ${{ github.event.pull_request.title }}"
          echo "Pull Request URL: ${{ github.event.pull_request.html_url }}"
      
      - name: Diagnose Status Checks
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT }}
          script: |
            // Get the combined status
            const { data: combinedStatus } = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.payload.pull_request.head.sha
            });
            
            console.log(`Combined status: ${combinedStatus.state}`);
            console.log(`Total status checks: ${combinedStatus.statuses.length}`);
            
            // Log detailed information about each status
            if (combinedStatus.statuses.length > 0) {
              console.log("\nDetailed Status Checks:");
              for (const status of combinedStatus.statuses) {
                console.log(`- ${status.context}: ${status.state} (${status.description})`);
                console.log(`  Target URL: ${status.target_url || 'N/A'}`);
              }
            }
            
            // Get check runs (GitHub Actions and other integrations)
            const { data: checks } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.payload.pull_request.head.sha
            });
            
            console.log(`\nTotal check runs: ${checks.total_count}`);
            
            // Count checks by status and conclusion
            const statusCounts = {};
            const conclusionCounts = {};
            const pendingChecks = [];
            const failingChecks = [];
            
            for (const check of checks.check_runs) {
              // Track status counts
              statusCounts[check.status] = (statusCounts[check.status] || 0) + 1;
              
              // Track conclusion counts (if completed)
              if (check.status === 'completed') {
                conclusionCounts[check.conclusion] = (conclusionCounts[check.conclusion] || 0) + 1;
              }
              
              // Track pending checks
              if (check.status !== 'completed') {
                pendingChecks.push({
                  name: check.name,
                  status: check.status,
                  startedAt: check.started_at
                });
              }
              
              // Track failing checks
              if (check.status === 'completed' && check.conclusion !== 'success') {
                failingChecks.push({
                  name: check.name,
                  conclusion: check.conclusion,
                  detailsUrl: check.details_url
                });
              }
            }
            
            console.log("\nCheck Run Status Summary:");
            for (const [status, count] of Object.entries(statusCounts)) {
              console.log(`- ${status}: ${count}`);
            }
            
            console.log("\nCheck Run Conclusion Summary:");
            for (const [conclusion, count] of Object.entries(conclusionCounts)) {
              console.log(`- ${conclusion}: ${count}`);
            }
            
            if (pendingChecks.length > 0) {
              console.log("\nPending Checks:");
              for (const check of pendingChecks) {
                console.log(`- ${check.name} (${check.status}, started: ${check.startedAt || 'N/A'})`);
              }
            }
            
            if (failingChecks.length > 0) {
              console.log("\nFailing Checks:");
              for (const check of failingChecks) {
                console.log(`- ${check.name} (${check.conclusion})`);
                console.log(`  Details: ${check.detailsUrl}`);
              }
            }
            
            // Check Required Status Checks
            try {
              const { data: branch } = await github.rest.repos.getBranch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                branch: context.payload.pull_request.base.ref
              });
              
              if (branch.protection && branch.protection.required_status_checks) {
                console.log("\nRequired Status Checks:");
                console.log(`- Strict: ${branch.protection.required_status_checks.strict}`);
                console.log(`- Required Contexts: ${JSON.stringify(branch.protection.required_status_checks.contexts)}`);
                
                // Check which required checks are still pending or failing
                if (branch.protection.required_status_checks.contexts.length > 0) {
                  console.log("\nStatus of Required Checks:");
                  
                  for (const requiredContext of branch.protection.required_status_checks.contexts) {
                    // Check in statuses
                    const matchingStatus = combinedStatus.statuses.find(s => s.context === requiredContext);
                    
                    // Check in check runs
                    const matchingCheck = checks.check_runs.find(c => c.name === requiredContext);
                    
                    if (matchingStatus) {
                      console.log(`- ${requiredContext}: ${matchingStatus.state} (${matchingStatus.description || 'No description'})`);
                    } else if (matchingCheck) {
                      console.log(`- ${requiredContext}: ${matchingCheck.status} / ${matchingCheck.conclusion || 'pending'}`);
                    } else {
                      console.log(`- ${requiredContext}: Not found (may be pending or not started)`);
                    }
                  }
                }
              } else {
                console.log("\nNo branch protection rules with required status checks found.");
              }
            } catch (error) {
              console.log("\nError fetching branch protection rules:", error.message);
            }
            
            // Check PR mergeable status
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            console.log("\nPR Mergeable Status:");
            console.log(`- Mergeable: ${pr.mergeable}`);
            console.log(`- Mergeable State: ${pr.mergeable_state}`);
            
            // Check if PR has approved reviews
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            const approvals = reviews.filter(review => review.state === 'APPROVED');
            console.log(`\nApproved Reviews: ${approvals.length}`);
            
            return {
              combinedState: combinedStatus.state,
              pendingChecksCount: pendingChecks.length,
              failingChecksCount: failingChecks.length,
              mergeable: pr.mergeable,
              mergeableState: pr.mergeable_state
            };
